(()=>{"use strict";const t=1,e=2;function i(t){return(t|=0)?31-Math.clz32(t&-t):0}const s=[0,36,73,109,146,182,219,255],r=[0,17,34,51,68,85,102,119,136,153,170,187,204,221,238,255],h=[0,8,16,25,33,41,49,58,66,74,82,90,99,107,115,123,132,140,148,156,165,173,181,189,197,206,214,222,230,239,247,255],a=[0,4,8,12,16,20,24,28,32,36,40,45,49,53,57,61,65,69,73,77,81,85,89,93,97,101,105,109,113,117,121,125,130,134,138,142,146,150,154,158,162,166,170,174,178,182,186,190,194,198,202,206,210,215,219,223,227,231,235,239,243,247,251,255],n={Core:"BITMAPCOREHEADER",Info:"BITMAPINFOHEADER",V2:"BITMAPV2INFOHEADER",V3:"BITMAPV3INFOHEADER",V4:"BITMAPV4HEADER",V5:"BITMAPV5HEADER"},o={RGB:0,RLE8:1,RLE4:2,Bitfields:3,JPEG:4,PNG:5,AlphaBitfields:6};class d{constructor(t,e,i){this.b=t,this.g=e,this.r=i}}class l{constructor(t,e){this.length=t,this.shift=e}static fromMask(t,e){if(0===t)return new l(0,0);let s=i(t),r=i(~(t>>>s));if(r!==(h=t,16843009*((h=(858993459&(h-=h>>1&1431655765))+(h>>2&858993459))+(h>>4)&252645135)>>24))throw new Error("Non-contiguous bitfield mask");var h;if(r+s>e)throw new Error("Bitfield mask too long");return r>8&&(s+=r-8,r=8),new l(r,s)}read(t){switch(t>>=this.shift,this.length){case 1:return 255*(1&t);case 2:return 85*(3&t);case 3:return s[7&t];case 4:return r[15&t];case 5:return h[31&t];case 6:return a[63&t];case 7:return(127&t)<<1|(127&t)>>6;case 8:return 255&t;default:throw new Error("Unhandled bitfield mask length ".concat(this.length))}}}class c{constructor(t,e,i,s){this.r=t,this.g=e,this.b=i,this.a=s}static fromMask(t,e,i,s,r){return new c(l.fromMask(t,r),l.fromMask(e,r),l.fromMask(i,r),l.fromMask(s,r))}}class u{constructor(t){this.data=t,this.dataView=new DataView(t),this.headerType=null,this.readStrategy=null,this.bitFields=null,this.paletteColors=null,this.initialized=!1}readUint8(t){return this.dataView.getUint8(t)}readUint16(t){return this.dataView.getUint16(t,!0)}readUint32(t){return this.dataView.getUint32(t,!0)}readInt32(t){return this.dataView.getInt32(t,!0)}get headerSize(){return this.readUint32(0)}get width(){return this.headerType===n.Core?this.readUint16(4):this.readInt32(4)}get height(){return this.headerType===n.Core?this.readUint16(6):this.readInt32(8)}get planes(){return this.headerType===n.Core?this.readUint16(8):this.readUint16(12)}get depth(){return this.headerType===n.Core?this.readUint16(10):this.readUint16(14)}get compression(){return this.headerType===n.Core?o.RGB:this.readUint32(16)}get colorsUsed(){return this.headerType===n.Core?0:this.readUint32(32)}get optionalBitMasksSize(){if(this.headerType===n.Info)switch(this.compression){case o.Bitfields:return 12;case o.AlphaBitfields:return 16}return 0}get paletteColorCount(){return this.colorsUsed?this.colorsUsed:this.depth<=8?1<<this.depth:0}get paletteSize(){const t=this.headerType===n.Core?3:4;return this.paletteColorCount*t}get stride(){return(this.width*this.depth+31&-32)>>3}get hasBitMasks(){switch(this.headerType){case n.Core:return!1;case n.Info:return this.compression===o.Bitfields||this.compression===o.AlphaBitfields;default:return!0}}get redMask(){return this.hasBitMasks?this.readUint32(40):0}get greenMask(){return this.hasBitMasks?this.readUint32(44):0}get blueMask(){return this.hasBitMasks?this.readUint32(48):0}get alphaMask(){if(!this.hasBitMasks||this.headerType===n.V2)return 0;this.readUint32(52)}colorFromPalette(t){return this.initialize(),t>=this.paletteColors.length?this.colorFromPalette(0):this.paletteColors[t]}validateHeader(){if(this.dataView.byteLength<4||this.dataView.byteLength<this.headerSize)throw new Error("Truncated header");if(!Object.values(n).includes(this.headerType))throw new Error("Unknown header type with size ".concat(this.headerSize));if(this.width<0)throw new Error("Image width less than zero");if(this.width>1073741824||this.height<-1073741824||this.height>1073741824)throw new Error("Image dimensions out of bounds");if(1!==this.planes)throw new Error("Invalid number of color planes (".concat(this.planes,")"));switch(this.compression){case o.RGB:this.validateCompressionDepth("RGB",1,2,4,8,16,24,32);break;case o.RLE8:this.validateCompressionDepth("RLE8",8);break;case o.RLE4:this.validateCompressionDepth("RLE4",4);break;case o.Bitfields:case o.AlphaBitfields:this.validateCompressionDepth("Bitfields",16,32);break;default:throw new Error("Unsupported compression (".concat(this.compression,")"))}if(this.headerType===n.Core&&this.depth>24)throw new Error("Invalid bit depth for ".concat(this.headerType," (").concat(this.depth,")"));if(this.colorsUsed>1<<this.depth)throw new Error("Palette size ".concat(this.paletteColorCount," exceeds maximum value for ").concat(this.depth,"-bit image"))}validateCompressionDepth(t){for(var e=arguments.length,i=new Array(e>1?e-1:0),s=1;s<e;s++)i[s-1]=arguments[s];if(!i.includes(this.depth))throw new Error("Invalid bit depth for ".concat(t," (").concat(this.depth,")"))}determineHeaderType(){if(!(this.dataView.byteLength<4))switch(this.headerSize){case 12:this.headerType=n.Core;break;case 40:this.headerType=n.Info;break;case 52:this.headerType=n.V2;break;case 56:this.headerType=n.V3;break;case 108:this.headerType=n.V4;break;case 124:this.headerType=n.V5}}determineReadStrategy(){switch(this.compression){case o.RLE4:case o.RLE8:return void(this.readStrategy=new b(this))}switch(this.depth){case 1:case 2:case 4:case 8:this.readStrategy=new y(this);break;case 16:case 24:case 32:this.readStrategy=new w(this);break;default:throw Error("Unhandled bit depth: ".concat(this.depth))}}decodeBitfields(){if([o.Bitfields,o.AlphaBitfields].includes(this.compression))this.bitFields=c.fromMask(this.redMask,this.greenMask,this.blueMask,this.alphaMask,this.depth);else switch(this.depth){case 16:this.bitFields=c.fromMask(31744,992,31,0,this.depth);break;case 24:case 32:this.bitFields=c.fromMask(16711680,65280,255,0,this.depth)}}indexPalette(){if(this.depth>8)return;this.paletteColors=new Array(this.paletteColorCount);let t=this.headerSize+this.optionalBitMasksSize;for(let e=0;e<this.paletteColors.length;++e)this.paletteColors[e]=new d(this.readUint8(t++),this.readUint8(t++),this.readUint8(t++)),this.headerType!==n.Core&&t++}initialize(){this.initialized||(this.determineHeaderType(),this.validateHeader(),this.determineReadStrategy(),this.decodeBitfields(),this.indexPalette(),this.initialized=!0)}read(){this.initialize();const t=this.width*Math.abs(this.height)*4,e=new Uint8ClampedArray(t);return this.readStrategy.read(e),e}}class p{constructor(t){this.reader=t,this.width=this.reader.width,this.height=this.reader.height}read(t){throw new Error("ReadStrategy.read() must be implemented")}getAlpha(t,e,i){return 0!==t||0!==e||0!==i?255:0}}class f extends p{read(t){const e=Math.abs(this.height),i=this.height<0;for(let s=0;s<e;++s){const e=i?s:this.height-1-s,r=this.width*s*4,h=this.reader.headerSize+this.reader.optionalBitMasksSize+this.reader.paletteSize+this.reader.stride*e;this.readLine(t,r,h)}}readLine(t,e,i){throw new Error("LineByLineReadStrategy.readLine() must be implemented")}}class w extends f{constructor(t){super(t),this.bytesPerPixel=this.reader.depth>>3}readLine(t,e,i){for(let s=0;s<this.width;++s){let s=0,r=0,h=0,a=this.readUint32WithZeroPadding(i);s=this.bitFields.r.read(a),r=this.bitFields.g.read(a),h=this.bitFields.b.read(a),t[e++]=s,t[e++]=r,t[e++]=h,t[e++]=this.getAlpha(s,r,h),i+=this.bytesPerPixel}}readUint32WithZeroPadding(t){if(t+4<=this.reader.dataView.byteLength)return this.reader.readUint32(t);let e=new Uint8Array([0,0,0,0]);for(let i=0;i<e.length&&!(t>=this.reader.dataView.byteLength);++i)e[i]=this.reader.readUint8(t++);return new DataView(e.buffer).getUint32(0,!0)}get bitFields(){return this.reader.bitFields}}function g(t){switch(t){case 1:return t=>{let e=new Array(8);for(let i=0;i<8;++i)e[7-i]=(t&1<<i)>>i;return e};case 2:return t=>[(192&t)>>6,(48&t)>>4,(12&t)>>2,3&t];case 4:return t=>[(240&t)>>4,15&t];case 8:return t=>[t];default:throw Error("Unhandled bit depth: ".concat(t))}}class y extends f{constructor(t){super(t),this.pixelsPerByte=8/this.reader.depth,this.bytesPerLine=Math.ceil(this.width/this.pixelsPerByte),this.getPaletteIndices=g(this.reader.depth)}readLine(t,e,i){let s=0;for(let r=0;r<this.bytesPerLine;++r){const r=this.readUint8WithZeroPadding(i),h=this.getPaletteIndices(r);for(let i of h){const r=this.reader.colorFromPalette(i),{b:h,g:a,r:n}=r;if(t[e++]=n,t[e++]=a,t[e++]=h,t[e++]=this.getAlpha(n,a,h),++s===this.width)return}++i}}readUint8WithZeroPadding(t){return t<this.reader.dataView.byteLength?this.reader.readUint8(t):0}}class b extends p{constructor(t){super(t),this.compression=t.compression,this.getPaletteIndices=g(this.reader.depth),this.init()}init(){this.dataPos=this.reader.headerSize+this.reader.optionalBitMasksSize+this.reader.paletteSize,this.x=0,this.y=0}validatePosition(){if(this.x>=this.width||this.y>=Math.abs(this.height))throw new Error("Image output position out of bounds")}nextLine(){this.x=0,this.y++,this.validatePosition()}setPixel(t,e){const i=this.height<0?this.y:this.height-1-this.y,s=this.width*i*4+4*this.x,r=this.reader.colorFromPalette(t),{b:h,g:a,r:n}=r;e[s+0]=n,e[s+1]=a,e[s+2]=h,e[s+3]=this.getAlpha(n,a,h),this.x++}executeInstruction(t,e){switch(t){case 0:if(this.y+1===Math.abs(this.height))return!1;this.nextLine();break;case 1:return!1;case 2:this.x+=this.readUint8(),this.y+=this.readUint8(),this.validatePosition();break;default:const i=t;let s=i;this.compression===o.RLE4&&(s=Math.trunc((i+1)/2));let r=[];for(let t=0;t<s;++t){const t=this.readUint8();r.push(...this.getPaletteIndices(t))}r.length=i,this.dataPos+=1&this.dataPos;for(let t of r){if(this.x===this.width)return!1;this.setPixel(t,e)}}return!0}read(t){for(this.init();this.dataPos<this.dataLength;){const e=this.readUint8();if(0===e){const e=this.readUint8();if(!this.executeInstruction(e,t))break}else{const i=e,s=this.getPaletteIndices(this.readUint8());for(let e=0;e<i;++e){if(this.x===this.width){this.nextLine();break}this.setPixel(s[e%s.length],t)}}}return this.imageData}readUint8(){try{return this.reader.readUint8(this.dataPos++)}catch(t){throw new Error("Ran out of RLE data")}}get dataLength(){return this.reader.dataView.byteLength}}const U=2;class k{constructor(t,e){this.resourceType=t,this.subdirectoryOffset=e}}class E{constructor(t,e,i,s){this.offset=t,this.size=e,this.codePage=i,this.unused=s}}class I{constructor(t,e,i,s){this.start=t,this.size=e,this.width=i,this.height=s}}class m{constructor(t){this.file=t,this.dataView=new DataView(t),this.position=0,this.virtualAddress=0,this.rootAddress=0,this.bitmapDirectoryEntry=new k,this.resourceInfo=new Map,this.readHeader(),this.readBitmapTable()}seek(t){this.position=t}skip(t){this.position+=t}readUint16(){let t=this.dataView.getUint16(this.position,!0);return this.position+=2,t}readUint32(){let t=this.dataView.getUint32(this.position,!0);return this.position+=4,t}readInt32(){let t=this.dataView.getInt32(this.position,!0);return this.position+=4,t}readString(t){let e=new TextDecoder("utf-8").decode(new Uint8Array(this.file.slice(this.position,this.position+t)));return this.position+=t,e}readDirectoryEntryCount(){return this.skip(12),this.readUint16()+this.readUint16()}readResourceDirectoryEntry(){let t=this.readUint32(),e=this.readUint32();return new k(t,e)}readResourceDataEntry(){let t=this.readUint32(),e=this.readUint32(),i=this.readUint32(),s=this.readUint32();return new E(t,e,i,s)}readHeader(){this.seek(60);let t=this.readUint16();if(this.skip(t-60-2),"PE\0\0"!==this.readString(4))throw new Error("Invalid PE file signature");this.skip(2);let e=this.readUint16();this.skip(128),this.virtualAddress=this.readUint32(),this.skip(120);for(let t=0;t<e;++t){if(this.readUint32()==this.virtualAddress){this.skip(4),this.rootAddress=this.readUint32();break}this.skip(36)}if(0==this.rootAddress)throw new Error("Invalid root address");this.seek(this.rootAddress);let i=this.readDirectoryEntryCount();for(let t=0;t<i;++t){let t=this.readResourceDirectoryEntry();if(t.resourceType===U)return this.bitmapDirectoryEntry=t,void(this.bitmapDirectoryEntry.subdirectoryOffset-=2147483648)}throw new Error("Missing bitmap resource directory")}readBitmapTable(){this.seek(this.rootAddress+this.bitmapDirectoryEntry.subdirectoryOffset);let t=this.readDirectoryEntryCount(),e=new Array;for(let i=0;i<t;++i){let t=this.readResourceDirectoryEntry();t.subdirectoryOffset>2147483648&&(t.subdirectoryOffset-=2147483648,e.push(t))}for(let t of e){this.seek(this.rootAddress+t.subdirectoryOffset+20);let e=this.readUint32();this.seek(this.rootAddress+e);let i,s,r=this.readResourceDataEntry(),h=r.offset-this.virtualAddress+this.rootAddress,a=r.size;this.seek(h),12===this.readUint32()?(i=this.readUint16(),s=this.readUint16()):(i=Math.abs(this.readInt32()),s=Math.abs(this.readInt32())),this.resourceInfo.set(t.resourceType,new I(h,a,i,s))}}getResourceIDs(){return this.resourceInfo.keys()}getResourceInfo(t){let e=this.resourceInfo.get(t);return e||(e=null),e}readResource(t){return this.file.slice(t.start,t.start+t.size)}}self.egfs=new Map,self.loadDIB=function(t){try{let i=egfs.get(t.fileID);if(i){let s=i.getResourceInfo(t.resourceID);if(s){let r=i.readResource(s),h=new u(r).read();postMessage({loadType:e,fileID:t.fileID,resourceID:t.resourceID,pixels:h.buffer},[h.buffer])}}}catch(i){postMessage({loadType:e,fileID:t.fileID,resourceID:t.resourceID,error:i})}},self.loadEGF=function(e){try{if(egfs.has(e.fileID))throw new Error("EGF ".concat(e.fileID," was already loaded."));let i=new m(e.buffer);egfs.set(e.fileID,i),postMessage({loadType:t,fileID:e.fileID,resourceInfo:i.resourceInfo})}catch(i){postMessage({loadType:t,fileID:e.fileID,error:i})}},onmessage=function(i){let s=i.data;switch(s.loadType){case e:loadDIB(s);break;case t:loadEGF(s);break;default:throw new Error("Unhandled LoadType: ".concat(s.loadType))}}})();
//# sourceMappingURL=bundle.min.worker.js.map