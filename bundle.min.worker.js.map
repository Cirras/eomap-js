{"version":3,"file":"bundle.min.worker.js","mappings":"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","sources":["webpack://eomap-js/./src/core/gfx/load/load-type.js","webpack://eomap-js/./src/core/util/math-utils.js","webpack://eomap-js/./src/core/gfx/load/dib-reader.js","webpack://eomap-js/./src/core/gfx/load/pe-reader.js","webpack://eomap-js/./src/core/gfx/load/gfx-loader.worker.js"],"sourcesContent":["export const LoadType = {\n  EGF: 1,\n  DIB: 2,\n};\n","export function trailingZeros(n) {\n  n |= 0;\n  return n ? 31 - Math.clz32(n & -n) : 0;\n}\n\nexport function countOnes(n) {\n  n = n - ((n >> 1) & 0x55555555);\n  n = (n & 0x33333333) + ((n >> 2) & 0x33333333);\n  return (((n + (n >> 4)) & 0xf0f0f0f) * 0x1010101) >> 24;\n}\n","import { countOnes, trailingZeros } from \"../../util/math-utils\";\n\nconst LOOKUP_TABLE_3_BIT_TO_8_BIT = [0, 36, 73, 109, 146, 182, 219, 255];\n\nconst LOOKUP_TABLE_4_BIT_TO_8_BIT = [\n  0, 17, 34, 51, 68, 85, 102, 119, 136, 153, 170, 187, 204, 221, 238, 255,\n];\n\nconst LOOKUP_TABLE_5_BIT_TO_8_BIT = [\n  0, 8, 16, 25, 33, 41, 49, 58, 66, 74, 82, 90, 99, 107, 115, 123, 132, 140,\n  148, 156, 165, 173, 181, 189, 197, 206, 214, 222, 230, 239, 247, 255,\n];\n\nconst LOOKUP_TABLE_6_BIT_TO_8_BIT = [\n  0, 4, 8, 12, 16, 20, 24, 28, 32, 36, 40, 45, 49, 53, 57, 61, 65, 69, 73, 77,\n  81, 85, 89, 93, 97, 101, 105, 109, 113, 117, 121, 125, 130, 134, 138, 142,\n  146, 150, 154, 158, 162, 166, 170, 174, 178, 182, 186, 190, 194, 198, 202,\n  206, 210, 215, 219, 223, 227, 231, 235, 239, 243, 247, 251, 255,\n];\n\nconst HeaderType = {\n  Core: \"BITMAPCOREHEADER\",\n  Info: \"BITMAPINFOHEADER\",\n  V2: \"BITMAPV2INFOHEADER\",\n  V3: \"BITMAPV3INFOHEADER\",\n  V4: \"BITMAPV4HEADER\",\n  V5: \"BITMAPV5HEADER\",\n};\n\nconst Compression = {\n  RGB: 0,\n  RLE8: 1,\n  RLE4: 2,\n  Bitfields: 3,\n  JPEG: 4,\n  PNG: 5,\n  AlphaBitfields: 6,\n};\n\nclass PaletteColor {\n  constructor(b, g, r) {\n    this.b = b;\n    this.g = g;\n    this.r = r;\n  }\n}\n\n// Bitfield(s) implementation is based directly on the image-rs BMPDecoder\n// See: https://github.com/image-rs/image/blob/v0.24.4/src/codecs/bmp/decoder.rs#L479\nclass Bitfield {\n  constructor(length, shift) {\n    this.length = length;\n    this.shift = shift;\n  }\n\n  static fromMask(mask, maxLength) {\n    if (mask === 0) {\n      return new Bitfield(0, 0);\n    }\n\n    let shift = trailingZeros(mask);\n    let length = trailingZeros(~(mask >>> shift));\n\n    if (length !== countOnes(mask)) {\n      throw new Error(\"Non-contiguous bitfield mask\");\n    }\n\n    if (length + shift > maxLength) {\n      throw new Error(\"Bitfield mask too long\");\n    }\n\n    if (length > 8) {\n      shift += length - 8;\n      length = 8;\n    }\n\n    return new Bitfield(length, shift);\n  }\n\n  read(data) {\n    data = data >> this.shift;\n    switch (this.length) {\n      case 1:\n        return (data & 0b1) * 0xff;\n      case 2:\n        return (data & 0b11) * 0x55;\n      case 3:\n        return LOOKUP_TABLE_3_BIT_TO_8_BIT[data & 0b00_0111];\n      case 4:\n        return LOOKUP_TABLE_4_BIT_TO_8_BIT[data & 0b00_1111];\n      case 5:\n        return LOOKUP_TABLE_5_BIT_TO_8_BIT[data & 0b01_1111];\n      case 6:\n        return LOOKUP_TABLE_6_BIT_TO_8_BIT[data & 0b11_1111];\n      case 7:\n        return ((data & 0x7f) << 1) | ((data & 0x7f) >> 6);\n      case 8:\n        return data & 0xff;\n      default:\n        throw new Error(`Unhandled bitfield mask length ${this.length}`);\n    }\n  }\n}\n\nclass Bitfields {\n  constructor(r, g, b, a) {\n    this.r = r;\n    this.g = g;\n    this.b = b;\n    this.a = a;\n  }\n\n  static fromMask(redMask, greenMask, blueMask, alphaMask, maxLength) {\n    return new Bitfields(\n      Bitfield.fromMask(redMask, maxLength),\n      Bitfield.fromMask(greenMask, maxLength),\n      Bitfield.fromMask(blueMask, maxLength),\n      Bitfield.fromMask(alphaMask, maxLength)\n    );\n  }\n}\n\nexport class DIBReader {\n  constructor(buffer) {\n    this.data = buffer;\n    this.dataView = new DataView(buffer);\n\n    this.headerType = null;\n    this.readStrategy = null;\n    this.bitFields = null;\n    this.paletteColors = null;\n\n    this.initialized = false;\n  }\n\n  readUint8(position) {\n    return this.dataView.getUint8(position);\n  }\n\n  readUint16(position) {\n    return this.dataView.getUint16(position, true);\n  }\n\n  readUint32(position) {\n    return this.dataView.getUint32(position, true);\n  }\n\n  readInt32(position) {\n    return this.dataView.getInt32(position, true);\n  }\n\n  get headerSize() {\n    return this.readUint32(0);\n  }\n\n  get width() {\n    if (this.headerType === HeaderType.Core) {\n      return this.readUint16(4);\n    } else {\n      return this.readInt32(4);\n    }\n  }\n\n  get height() {\n    if (this.headerType === HeaderType.Core) {\n      return this.readUint16(6);\n    } else {\n      return this.readInt32(8);\n    }\n  }\n\n  get planes() {\n    if (this.headerType === HeaderType.Core) {\n      return this.readUint16(8);\n    } else {\n      return this.readUint16(12);\n    }\n  }\n\n  get depth() {\n    if (this.headerType === HeaderType.Core) {\n      return this.readUint16(10);\n    } else {\n      return this.readUint16(14);\n    }\n  }\n\n  get compression() {\n    if (this.headerType === HeaderType.Core) {\n      return Compression.RGB;\n    } else {\n      return this.readUint32(16);\n    }\n  }\n\n  get colorsUsed() {\n    if (this.headerType === HeaderType.Core) {\n      return 0;\n    } else {\n      return this.readUint32(32);\n    }\n  }\n\n  get optionalBitMasksSize() {\n    // Present only in case the DIB header is the BITMAPINFOHEADER and the\n    // Compression Method member is set to either BI_BITFIELDS or BI_ALPHABITFIELDS\n    if (this.headerType === HeaderType.Info) {\n      switch (this.compression) {\n        case Compression.Bitfields:\n          return 12;\n        case Compression.AlphaBitfields:\n          return 16;\n        default:\n        // do nothing\n      }\n    }\n\n    return 0;\n  }\n\n  get paletteColorCount() {\n    if (this.colorsUsed) {\n      return this.colorsUsed;\n    } else if (this.depth <= 8) {\n      return 1 << this.depth;\n    } else {\n      return 0;\n    }\n  }\n\n  get paletteSize() {\n    const bytesPerColor = this.headerType === HeaderType.Core ? 3 : 4;\n    return this.paletteColorCount * bytesPerColor;\n  }\n\n  get stride() {\n    return ((this.width * this.depth + 31) & ~31) >> 3;\n  }\n\n  get hasBitMasks() {\n    switch (this.headerType) {\n      case HeaderType.Core:\n        return false;\n      case HeaderType.Info:\n        return (\n          this.compression === Compression.Bitfields ||\n          this.compression === Compression.AlphaBitfields\n        );\n      default:\n        return true;\n    }\n  }\n\n  get redMask() {\n    if (!this.hasBitMasks) {\n      return 0;\n    } else {\n      return this.readUint32(40);\n    }\n  }\n\n  get greenMask() {\n    if (!this.hasBitMasks) {\n      return 0;\n    } else {\n      return this.readUint32(44);\n    }\n  }\n\n  get blueMask() {\n    if (!this.hasBitMasks) {\n      return 0;\n    } else {\n      return this.readUint32(48);\n    }\n  }\n\n  get alphaMask() {\n    if (!this.hasBitMasks || this.headerType === HeaderType.V2) {\n      return 0;\n    } else {\n      this.readUint32(52);\n    }\n  }\n\n  colorFromPalette(index) {\n    this.initialize();\n\n    if (index >= this.paletteColors.length) {\n      return this.colorFromPalette(0);\n    }\n\n    return this.paletteColors[index];\n  }\n\n  validateHeader() {\n    if (\n      this.dataView.byteLength < 4 ||\n      this.dataView.byteLength < this.headerSize\n    ) {\n      throw new Error(\"Truncated header\");\n    }\n\n    if (!Object.values(HeaderType).includes(this.headerType)) {\n      throw new Error(`Unknown header type with size ${this.headerSize}`);\n    }\n\n    if (this.width < 0) {\n      throw new Error(\"Image width less than zero\");\n    }\n\n    if (\n      this.width > 0x40000000 ||\n      this.height < -0x40000000 ||\n      this.height > 0x40000000\n    ) {\n      throw new Error(\"Image dimensions out of bounds\");\n    }\n\n    if (this.planes !== 1) {\n      throw new Error(`Invalid number of color planes (${this.planes})`);\n    }\n\n    switch (this.compression) {\n      case Compression.RGB:\n        this.validateCompressionDepth(\"RGB\", 1, 2, 4, 8, 16, 24, 32);\n        break;\n\n      case Compression.RLE8:\n        this.validateCompressionDepth(\"RLE8\", 8);\n        break;\n\n      case Compression.RLE4:\n        this.validateCompressionDepth(\"RLE4\", 4);\n        break;\n\n      case Compression.Bitfields:\n      case Compression.AlphaBitfields:\n        this.validateCompressionDepth(\"Bitfields\", 16, 32);\n        break;\n\n      default:\n        throw new Error(`Unsupported compression (${this.compression})`);\n    }\n\n    if (this.headerType === HeaderType.Core && this.depth > 24) {\n      throw new Error(\n        `Invalid bit depth for ${this.headerType} (${this.depth})`\n      );\n    }\n\n    if (this.colorsUsed > 1 << this.depth) {\n      throw new Error(\n        `Palette size ${this.paletteColorCount} exceeds maximum value for ${this.depth}-bit image`\n      );\n    }\n  }\n\n  validateCompressionDepth(name, ...allowedDepths) {\n    if (!allowedDepths.includes(this.depth)) {\n      throw new Error(`Invalid bit depth for ${name} (${this.depth})`);\n    }\n  }\n\n  determineHeaderType() {\n    if (this.dataView.byteLength < 4) {\n      return;\n    }\n    switch (this.headerSize) {\n      case 12:\n        this.headerType = HeaderType.Core;\n        break;\n      case 40:\n        this.headerType = HeaderType.Info;\n        break;\n      case 52:\n        this.headerType = HeaderType.V2;\n        break;\n      case 56:\n        this.headerType = HeaderType.V3;\n        break;\n      case 108:\n        this.headerType = HeaderType.V4;\n        break;\n      case 124:\n        this.headerType = HeaderType.V5;\n        break;\n    }\n  }\n\n  determineReadStrategy() {\n    switch (this.compression) {\n      case Compression.RLE4:\n      case Compression.RLE8:\n        this.readStrategy = new RLEReadStrategy(this);\n        return;\n      default:\n      // do nothing\n    }\n\n    switch (this.depth) {\n      case 1:\n      case 2:\n      case 4:\n      case 8:\n        this.readStrategy = new PalettedReadStrategy(this);\n        break;\n      case 16:\n      case 24:\n      case 32:\n        this.readStrategy = new RGBReadStrategy(this);\n        break;\n      default:\n        throw Error(`Unhandled bit depth: ${this.depth}`);\n    }\n  }\n\n  decodeBitfields() {\n    if (\n      [Compression.Bitfields, Compression.AlphaBitfields].includes(\n        this.compression\n      )\n    ) {\n      this.bitFields = Bitfields.fromMask(\n        this.redMask,\n        this.greenMask,\n        this.blueMask,\n        this.alphaMask,\n        this.depth\n      );\n    } else {\n      switch (this.depth) {\n        case 16:\n          this.bitFields = Bitfields.fromMask(\n            0x00007c00,\n            0x000003e0,\n            0x0000001f,\n            0x00000000,\n            this.depth\n          );\n          break;\n\n        case 24:\n        case 32:\n          this.bitFields = Bitfields.fromMask(\n            0x00ff0000,\n            0x0000ff00,\n            0x000000ff,\n            0x00000000,\n            this.depth\n          );\n          break;\n      }\n    }\n  }\n\n  indexPalette() {\n    if (this.depth > 8) {\n      return;\n    }\n\n    this.paletteColors = new Array(this.paletteColorCount);\n    let pos = this.headerSize + this.optionalBitMasksSize;\n\n    for (let i = 0; i < this.paletteColors.length; ++i) {\n      this.paletteColors[i] = new PaletteColor(\n        this.readUint8(pos++),\n        this.readUint8(pos++),\n        this.readUint8(pos++)\n      );\n\n      if (this.headerType !== HeaderType.Core) {\n        // rgbReserved is reserved and must be zero\n        // See: https://learn.microsoft.com/en-us/windows/win32/api/wingdi/ns-wingdi-rgbquad\n        pos++;\n      }\n    }\n  }\n\n  initialize() {\n    if (this.initialized) {\n      return;\n    }\n\n    this.determineHeaderType();\n    this.validateHeader();\n    this.determineReadStrategy();\n    this.decodeBitfields();\n    this.indexPalette();\n\n    this.initialized = true;\n  }\n\n  read() {\n    this.initialize();\n\n    const outputSize = this.width * Math.abs(this.height) * 4;\n    const imageData = new Uint8ClampedArray(outputSize);\n    this.readStrategy.read(imageData);\n\n    return imageData;\n  }\n}\n\nclass ReadStrategy {\n  constructor(reader) {\n    this.reader = reader;\n    this.width = this.reader.width;\n    this.height = this.reader.height;\n  }\n\n  read(_outBuffer) {\n    throw new Error(\"ReadStrategy.read() must be implemented\");\n  }\n\n  getAlpha(r, g, b) {\n    if (r !== 0 || g !== 0 || b !== 0) {\n      return 0xff;\n    } else {\n      return 0x00;\n    }\n  }\n}\n\nclass LineByLineReadStrategy extends ReadStrategy {\n  read(outBuffer) {\n    const rowCount = Math.abs(this.height);\n    const isTopDown = this.height < 0;\n\n    for (let row = 0; row < rowCount; ++row) {\n      const line = isTopDown ? row : this.height - 1 - row;\n\n      const outPos = this.width * row * 4;\n      const linePos =\n        this.reader.headerSize +\n        this.reader.optionalBitMasksSize +\n        this.reader.paletteSize +\n        this.reader.stride * line;\n\n      this.readLine(outBuffer, outPos, linePos);\n    }\n  }\n\n  readLine(_outBuffer, _outPos, _linePos) {\n    throw new Error(\"LineByLineReadStrategy.readLine() must be implemented\");\n  }\n}\n\nclass RGBReadStrategy extends LineByLineReadStrategy {\n  constructor(reader) {\n    super(reader);\n    this.bytesPerPixel = this.reader.depth >> 3;\n  }\n\n  readLine(outBuffer, outPos, linePos) {\n    for (let i = 0; i < this.width; ++i) {\n      let r = 0;\n      let g = 0;\n      let b = 0;\n\n      let p = this.readUint32WithZeroPadding(linePos);\n      r = this.bitFields.r.read(p);\n      g = this.bitFields.g.read(p);\n      b = this.bitFields.b.read(p);\n\n      outBuffer[outPos++] = r;\n      outBuffer[outPos++] = g;\n      outBuffer[outPos++] = b;\n      outBuffer[outPos++] = this.getAlpha(r, g, b);\n\n      linePos += this.bytesPerPixel;\n    }\n  }\n\n  readUint32WithZeroPadding(position) {\n    if (position + 4 <= this.reader.dataView.byteLength) {\n      return this.reader.readUint32(position);\n    }\n\n    let bytes = new Uint8Array([0, 0, 0, 0]);\n\n    for (let i = 0; i < bytes.length; ++i) {\n      if (position >= this.reader.dataView.byteLength) {\n        break;\n      }\n      bytes[i] = this.reader.readUint8(position++);\n    }\n\n    return new DataView(bytes.buffer).getUint32(0, true);\n  }\n\n  get bitFields() {\n    return this.reader.bitFields;\n  }\n}\n\nfunction createGetPaletteIndicesFunction(depth) {\n  switch (depth) {\n    case 1:\n      return (byte) => {\n        let indices = new Array(8);\n        for (let i = 0; i < 8; ++i) {\n          indices[7 - i] = (byte & (1 << i)) >> i;\n        }\n        return indices;\n      };\n    case 2:\n      return (byte) => {\n        return [\n          (byte & 0xc0) >> 6,\n          (byte & 0x30) >> 4,\n          (byte & 0x0c) >> 2,\n          byte & 0x03,\n        ];\n      };\n    case 4:\n      return (byte) => {\n        return [(byte & 0xf0) >> 4, byte & 0x0f];\n      };\n    case 8:\n      return (byte) => {\n        return [byte];\n      };\n    default:\n      throw Error(`Unhandled bit depth: ${depth}`);\n  }\n}\n\nclass PalettedReadStrategy extends LineByLineReadStrategy {\n  constructor(reader) {\n    super(reader);\n    this.pixelsPerByte = 8 / this.reader.depth;\n    this.bytesPerLine = Math.ceil(this.width / this.pixelsPerByte);\n    this.getPaletteIndices = createGetPaletteIndicesFunction(this.reader.depth);\n  }\n\n  readLine(outBuffer, outPos, linePos) {\n    let written = 0;\n\n    for (let i = 0; i < this.bytesPerLine; ++i) {\n      const byte = this.readUint8WithZeroPadding(linePos);\n      const paletteIndices = this.getPaletteIndices(byte);\n\n      for (let paletteIndex of paletteIndices) {\n        const color = this.reader.colorFromPalette(paletteIndex);\n        const { b, g, r } = color;\n\n        outBuffer[outPos++] = r;\n        outBuffer[outPos++] = g;\n        outBuffer[outPos++] = b;\n        outBuffer[outPos++] = this.getAlpha(r, g, b);\n\n        if (++written === this.width) {\n          return;\n        }\n      }\n\n      ++linePos;\n    }\n  }\n\n  readUint8WithZeroPadding(position) {\n    if (position < this.reader.dataView.byteLength) {\n      return this.reader.readUint8(position);\n    }\n    return 0;\n  }\n}\n\n// See: https://learn.microsoft.com/en-us/windows/win32/gdi/bitmap-compression\nclass RLEReadStrategy extends ReadStrategy {\n  constructor(reader) {\n    super(reader);\n    this.compression = reader.compression;\n    this.getPaletteIndices = createGetPaletteIndicesFunction(this.reader.depth);\n    this.init();\n  }\n\n  init() {\n    this.dataPos =\n      this.reader.headerSize +\n      this.reader.optionalBitMasksSize +\n      this.reader.paletteSize;\n    this.x = 0;\n    this.y = 0;\n  }\n\n  validatePosition() {\n    if (this.x >= this.width || this.y >= Math.abs(this.height)) {\n      throw new Error(\"Image output position out of bounds\");\n    }\n  }\n\n  nextLine() {\n    this.x = 0;\n    this.y++;\n    this.validatePosition();\n  }\n\n  setPixel(paletteIndex, outBuffer) {\n    const isTopDown = this.height < 0;\n    const line = isTopDown ? this.y : this.height - 1 - this.y;\n    const pos = this.width * line * 4 + this.x * 4;\n    const color = this.reader.colorFromPalette(paletteIndex);\n    const { b, g, r } = color;\n\n    outBuffer[pos + 0] = r;\n    outBuffer[pos + 1] = g;\n    outBuffer[pos + 2] = b;\n    outBuffer[pos + 3] = this.getAlpha(r, g, b);\n\n    this.x++;\n  }\n\n  executeInstruction(instruction, outBuffer) {\n    switch (instruction) {\n      // End of line\n      case 0:\n        if (this.y + 1 === Math.abs(this.height)) {\n          return false;\n        }\n        this.nextLine();\n        break;\n\n      // End of bitmap\n      case 1:\n        return false;\n\n      // Delta\n      case 2:\n        this.x += this.readUint8();\n        this.y += this.readUint8();\n        this.validatePosition();\n        break;\n\n      // Absolute\n      default:\n        const length = instruction;\n        let byteLength = length;\n        if (this.compression === Compression.RLE4) {\n          byteLength = Math.trunc((length + 1) / 2);\n        }\n\n        let paletteIndices = [];\n        for (let i = 0; i < byteLength; ++i) {\n          const byte = this.readUint8();\n          paletteIndices.push(...this.getPaletteIndices(byte));\n        }\n        paletteIndices.length = length;\n\n        // In absolute mode, each run must be aligned on a word boundary.\n        this.dataPos += this.dataPos & 1;\n\n        for (let paletteIndex of paletteIndices) {\n          if (this.x === this.width) {\n            // Absolute mode cannot span multiple rows\n            return false;\n          }\n          this.setPixel(paletteIndex, outBuffer);\n        }\n\n        break;\n    }\n\n    return true;\n  }\n\n  read(outBuffer) {\n    this.init();\n\n    while (this.dataPos < this.dataLength) {\n      const controlByte = this.readUint8();\n      if (controlByte === 0) {\n        const instruction = this.readUint8();\n        if (!this.executeInstruction(instruction, outBuffer)) {\n          break;\n        }\n      } else {\n        const length = controlByte;\n        const paletteIndices = this.getPaletteIndices(this.readUint8());\n        for (let i = 0; i < length; ++i) {\n          if (this.x === this.width) {\n            this.nextLine();\n            break;\n          }\n          this.setPixel(paletteIndices[i % paletteIndices.length], outBuffer);\n        }\n      }\n    }\n\n    return this.imageData;\n  }\n\n  readUint8() {\n    try {\n      return this.reader.readUint8(this.dataPos++);\n    } catch (e) {\n      throw new Error(\"Ran out of RLE data\");\n    }\n  }\n\n  get dataLength() {\n    return this.reader.dataView.byteLength;\n  }\n}\n","const ResourceType = {\n  CURSOR: 1,\n  BITMAP: 2,\n  ICON: 3,\n  MENU: 4,\n  DIALOG: 5,\n  STRING_TABLE: 6,\n  FONT_DIRECTORY: 7,\n  FONT: 8,\n  ACCELERATOR: 9,\n  UNFORMATTED: 10,\n  MESSAGE_TABLE: 11,\n  GROUP_CURSOR: 12,\n  GROUP_ICON: 14,\n  VERSION_INFORMATION: 16,\n};\n\nclass ResourceDirectoryEntry {\n  constructor(resourceType, subdirectoryOffset) {\n    this.resourceType = resourceType;\n    this.subdirectoryOffset = subdirectoryOffset;\n  }\n}\n\nclass ResourceDataEntry {\n  constructor(offset, size, codePage, unused) {\n    this.offset = offset;\n    this.size = size;\n    this.codePage = codePage;\n    this.unused = unused;\n  }\n}\n\nclass ResourceInfo {\n  constructor(start, size, width, height) {\n    this.start = start;\n    this.size = size;\n    this.width = width;\n    this.height = height;\n  }\n}\n\nexport class PEReader {\n  constructor(buffer) {\n    this.file = buffer;\n    this.dataView = new DataView(buffer);\n    this.position = 0;\n    this.virtualAddress = 0;\n    this.rootAddress = 0;\n\n    this.bitmapDirectoryEntry = new ResourceDirectoryEntry();\n    this.resourceInfo = new Map();\n\n    this.readHeader();\n    this.readBitmapTable();\n  }\n\n  seek(position) {\n    this.position = position;\n  }\n\n  skip(offset) {\n    this.position += offset;\n  }\n\n  readUint16() {\n    let result = this.dataView.getUint16(this.position, true);\n    this.position += 2;\n    return result;\n  }\n\n  readUint32() {\n    let result = this.dataView.getUint32(this.position, true);\n    this.position += 4;\n    return result;\n  }\n\n  readInt32() {\n    let result = this.dataView.getInt32(this.position, true);\n    this.position += 4;\n    return result;\n  }\n\n  readString(length) {\n    let decoder = new TextDecoder(\"utf-8\");\n    let result = decoder.decode(\n      new Uint8Array(this.file.slice(this.position, this.position + length))\n    );\n    this.position += length;\n    return result;\n  }\n\n  readDirectoryEntryCount() {\n    this.skip(0x0c);\n    let namedEntries = this.readUint16();\n    let idEntries = this.readUint16();\n    return namedEntries + idEntries;\n  }\n\n  readResourceDirectoryEntry() {\n    let resourceType = this.readUint32();\n    let subdirectoryOffset = this.readUint32();\n    return new ResourceDirectoryEntry(resourceType, subdirectoryOffset);\n  }\n\n  readResourceDataEntry() {\n    let offset = this.readUint32();\n    let size = this.readUint32();\n    let codePage = this.readUint32();\n    let unused = this.readUint32();\n    return new ResourceDataEntry(offset, size, codePage, unused);\n  }\n\n  readHeader() {\n    this.seek(0x3c);\n    let peHeaderAddress = this.readUint16();\n\n    this.skip(peHeaderAddress - 0x3c - 0x02);\n    let type = this.readString(4);\n    if (type !== \"PE\\0\\0\") {\n      throw new Error(\"Invalid PE file signature\");\n    }\n\n    this.skip(0x02);\n    let sections = this.readUint16();\n\n    this.skip(0x78 - 0x04 + 0x0c);\n    this.virtualAddress = this.readUint32();\n\n    this.skip(0x6c + 0x08 + 0x04);\n\n    for (let i = 0; i < sections; ++i) {\n      let checkVirtualAddress = this.readUint32();\n      if (checkVirtualAddress == this.virtualAddress) {\n        this.skip(0x04);\n        this.rootAddress = this.readUint32();\n        break;\n      }\n      this.skip(0x24);\n    }\n\n    if (this.rootAddress == 0) {\n      throw new Error(\"Invalid root address\");\n    }\n\n    this.seek(this.rootAddress);\n    let directoryEntryCount = this.readDirectoryEntryCount();\n\n    for (let i = 0; i < directoryEntryCount; ++i) {\n      let directoryEntry = this.readResourceDirectoryEntry();\n      if (directoryEntry.resourceType === ResourceType.BITMAP) {\n        this.bitmapDirectoryEntry = directoryEntry;\n        this.bitmapDirectoryEntry.subdirectoryOffset -= 0x80000000;\n        return;\n      }\n    }\n\n    throw new Error(\"Missing bitmap resource directory\");\n  }\n\n  readBitmapTable() {\n    this.seek(this.rootAddress + this.bitmapDirectoryEntry.subdirectoryOffset);\n\n    let directoryEntryCount = this.readDirectoryEntryCount();\n    let bitmapEntries = new Array();\n    for (let i = 0; i < directoryEntryCount; ++i) {\n      let entry = this.readResourceDirectoryEntry();\n      if (entry.subdirectoryOffset > 0x80000000) {\n        entry.subdirectoryOffset -= 0x80000000;\n        bitmapEntries.push(entry);\n      }\n    }\n\n    for (let entry of bitmapEntries) {\n      this.seek(this.rootAddress + entry.subdirectoryOffset + 20);\n      let entrySubdirectoryOffset = this.readUint32();\n\n      this.seek(this.rootAddress + entrySubdirectoryOffset);\n      let dataEntry = this.readResourceDataEntry();\n      let start = dataEntry.offset - this.virtualAddress + this.rootAddress;\n      let size = dataEntry.size;\n\n      this.seek(start);\n\n      let headerSize = this.readUint32();\n      let width;\n      let height;\n\n      if (headerSize === 12) {\n        // BITMAPCOREHEADER: width and height are unsigned 16-bit values\n        // See: https://learn.microsoft.com/windows/win32/api/wingdi/ns-wingdi-bitmapcoreheader\n        width = this.readUint16();\n        height = this.readUint16();\n      } else {\n        width = Math.abs(this.readInt32());\n        height = Math.abs(this.readInt32());\n      }\n\n      this.resourceInfo.set(\n        entry.resourceType,\n        new ResourceInfo(start, size, width, height)\n      );\n    }\n  }\n\n  getResourceIDs() {\n    return this.resourceInfo.keys();\n  }\n\n  getResourceInfo(resourceID) {\n    let info = this.resourceInfo.get(resourceID);\n    if (!info) {\n      info = null;\n    }\n    return info;\n  }\n\n  readResource(info) {\n    return this.file.slice(info.start, info.start + info.size);\n  }\n}\n","import { LoadType } from \"./load-type\";\nimport { DIBReader } from \"./dib-reader\";\nimport { PEReader } from \"./pe-reader\";\n\nself.egfs = new Map();\n\nself.loadDIB = function (data) {\n  try {\n    let egf = egfs.get(data.fileID);\n    if (egf) {\n      let info = egf.getResourceInfo(data.resourceID);\n      if (info) {\n        let dib = egf.readResource(info);\n        let reader = new DIBReader(dib);\n        let pixels = reader.read();\n        postMessage(\n          {\n            loadType: LoadType.DIB,\n            fileID: data.fileID,\n            resourceID: data.resourceID,\n            pixels: pixels.buffer,\n          },\n          [pixels.buffer]\n        );\n      }\n    }\n  } catch (e) {\n    postMessage({\n      loadType: LoadType.DIB,\n      fileID: data.fileID,\n      resourceID: data.resourceID,\n      error: e,\n    });\n  }\n};\n\nself.loadEGF = function (data) {\n  try {\n    if (egfs.has(data.fileID)) {\n      throw new Error(`EGF ${data.fileID} was already loaded.`);\n    }\n\n    let egf = new PEReader(data.buffer);\n\n    egfs.set(data.fileID, egf);\n\n    postMessage({\n      loadType: LoadType.EGF,\n      fileID: data.fileID,\n      resourceInfo: egf.resourceInfo,\n    });\n  } catch (e) {\n    postMessage({\n      loadType: LoadType.EGF,\n      fileID: data.fileID,\n      error: e,\n    });\n  }\n};\n\nonmessage = function (event) {\n  let data = event.data;\n\n  switch (data.loadType) {\n    case LoadType.DIB:\n      loadDIB(data);\n      break;\n    case LoadType.EGF:\n      loadEGF(data);\n      break;\n    default:\n      throw new Error(`Unhandled LoadType: ${data.loadType}`);\n  }\n};\n"],"names":["LoadType","trailingZeros","n","Math","clz32","LOOKUP_TABLE_3_BIT_TO_8_BIT","LOOKUP_TABLE_4_BIT_TO_8_BIT","LOOKUP_TABLE_5_BIT_TO_8_BIT","LOOKUP_TABLE_6_BIT_TO_8_BIT","HeaderType","Core","Info","V2","V3","V4","V5","Compression","RGB","RLE8","RLE4","Bitfields","JPEG","PNG","AlphaBitfields","PaletteColor","constructor","b","g","r","this","Bitfield","length","shift","mask","maxLength","Error","read","data","a","redMask","greenMask","blueMask","alphaMask","fromMask","DIBReader","buffer","dataView","DataView","headerType","readStrategy","bitFields","paletteColors","initialized","readUint8","position","getUint8","readUint16","getUint16","readUint32","getUint32","readInt32","getInt32","headerSize","width","height","planes","depth","compression","colorsUsed","optionalBitMasksSize","paletteColorCount","paletteSize","bytesPerColor","stride","hasBitMasks","colorFromPalette","index","initialize","validateHeader","byteLength","Object","values","includes","validateCompressionDepth","name","allowedDepths","determineHeaderType","determineReadStrategy","RLEReadStrategy","PalettedReadStrategy","RGBReadStrategy","decodeBitfields","indexPalette","Array","pos","i","outputSize","abs","imageData","Uint8ClampedArray","ReadStrategy","reader","_outBuffer","getAlpha","LineByLineReadStrategy","outBuffer","rowCount","isTopDown","row","line","outPos","linePos","readLine","_outPos","_linePos","super","bytesPerPixel","p","readUint32WithZeroPadding","bytes","Uint8Array","createGetPaletteIndicesFunction","byte","indices","pixelsPerByte","bytesPerLine","ceil","getPaletteIndices","written","readUint8WithZeroPadding","paletteIndices","paletteIndex","color","init","dataPos","x","y","validatePosition","nextLine","setPixel","executeInstruction","instruction","trunc","push","dataLength","controlByte","e","ResourceType","ResourceDirectoryEntry","resourceType","subdirectoryOffset","ResourceDataEntry","offset","size","codePage","unused","ResourceInfo","start","PEReader","file","virtualAddress","rootAddress","bitmapDirectoryEntry","resourceInfo","Map","readHeader","readBitmapTable","seek","skip","result","readString","TextDecoder","decode","slice","readDirectoryEntryCount","readResourceDirectoryEntry","readResourceDataEntry","peHeaderAddress","sections","directoryEntryCount","directoryEntry","bitmapEntries","entry","entrySubdirectoryOffset","dataEntry","set","getResourceIDs","keys","getResourceInfo","resourceID","info","get","readResource","self","egfs","loadDIB","egf","fileID","dib","pixels","postMessage","loadType","error","loadEGF","has","onmessage","event"],"sourceRoot":""}