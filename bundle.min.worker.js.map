{"version":3,"file":"bundle.min.worker.js","mappings":"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","sources":["webpack://eomap-js/./src/core/gfx/load/load-type.js","webpack://eomap-js/./src/core/gfx/load/dib-reader.js","webpack://eomap-js/./src/core/gfx/load/pe-reader.js","webpack://eomap-js/./src/core/gfx/load/gfx-loader.worker.js"],"sourcesContent":["export const LoadType = {\n  EGF: 1,\n  DIB: 2,\n};\n","const NUM_CONVERT_TABLES = 8;\nconst CONVERT_TABLES = (function () {\n  let tables = new Array(NUM_CONVERT_TABLES);\n  for (let i = 0; i < NUM_CONVERT_TABLES; ++i) {\n    let entries = 1 << (i + 1);\n    let table = new Array(entries);\n    for (let ii = 0; ii < entries; ++ii) {\n      table[ii] = Math.trunc((ii * 255) / (entries - 1));\n    }\n    tables[i] = table;\n  }\n  return tables;\n})();\n\nconst HeaderType = {\n  Core: \"BITMAPCOREHEADER\",\n  Info: \"BITMAPINFOHEADER\",\n  V2: \"BITMAPV2INFOHEADER\",\n  V3: \"BITMAPV3INFOHEADER\",\n  V4: \"BITMAPV4HEADER\",\n  V5: \"BITMAPV5HEADER\",\n};\n\nconst Compression = {\n  RGB: 0,\n  RLE8: 1,\n  RLE4: 2,\n  BitFields: 3,\n  JPEG: 4,\n  PNG: 5,\n};\n\nclass PaletteColor {\n  constructor(b, g, r) {\n    this.b = b;\n    this.g = g;\n    this.r = r;\n  }\n}\n\nfunction trailingZeros(n) {\n  n |= 0;\n  return n ? 31 - Math.clz32(n & -n) : 0;\n}\n\nclass BitField {\n  constructor(mask) {\n    if (mask === 0) {\n      this.shift = 0;\n      this.mask = 0;\n      this.length = 0;\n    }\n\n    this.shift = trailingZeros(mask);\n    this.mask = mask >> this.shift;\n    this.length = trailingZeros(~this.mask);\n  }\n\n  read(data) {\n    data = (data >> this.shift) & this.mask;\n    return CONVERT_TABLES[this.length - 1][data];\n  }\n}\n\nclass BitFields {\n  constructor(redMask, greenMask, blueMask, alphaMask) {\n    this.r = new BitField(redMask);\n    this.g = new BitField(greenMask);\n    this.b = new BitField(blueMask);\n    this.a = new BitField(alphaMask);\n  }\n}\n\nexport class DIBReader {\n  constructor(buffer) {\n    this.data = buffer;\n    this.dataView = new DataView(buffer);\n\n    this.headerType = null;\n    this.readLineStrategy = null;\n    this.bitFields = null;\n    this.paletteColors = null;\n\n    this.initialized = false;\n  }\n\n  readUint8(position) {\n    return this.dataView.getUint8(position);\n  }\n\n  readUint16(position) {\n    return this.dataView.getUint16(position, true);\n  }\n\n  readUint32(position) {\n    return this.dataView.getUint32(position, true);\n  }\n\n  readInt32(position) {\n    return this.dataView.getInt32(position, true);\n  }\n\n  get headerSize() {\n    return this.readUint32(0);\n  }\n\n  get width() {\n    if (this.headerType === HeaderType.Core) {\n      return this.readUint16(4);\n    } else {\n      return this.readInt32(4);\n    }\n  }\n\n  get height() {\n    if (this.headerType === HeaderType.Core) {\n      return this.readUint16(6);\n    } else {\n      return this.readInt32(8);\n    }\n  }\n\n  get planes() {\n    if (this.headerType === HeaderType.Core) {\n      return this.readUint16(8);\n    } else {\n      return this.readUint16(12);\n    }\n  }\n\n  get depth() {\n    if (this.headerType === HeaderType.Core) {\n      return this.readUint16(10);\n    } else {\n      return this.readUint16(14);\n    }\n  }\n\n  get compression() {\n    if (this.headerType === HeaderType.Core) {\n      return Compression.RGB;\n    } else {\n      return this.readUint32(16);\n    }\n  }\n\n  get colorsUsed() {\n    if (this.headerType === HeaderType.Core) {\n      return 0;\n    } else {\n      return this.readUint32(32);\n    }\n  }\n\n  get optionalBitMasksSize() {\n    if (\n      this.headerType === HeaderType.Info &&\n      this.compression == Compression.BitFields\n    ) {\n      // The Windows NT variant of the Windows 3.x BMP format can store 16-bit and 32-bit\n      // data in a BMP file.\n      // If the bitmap contains 16 or 32 bits per pixel, then only BitFields Compression is\n      // supported and the redMask, greenMask, and blueMask fields will be present following\n      // the header in place of a color palette.\n      // Otherwise, the file is identical to a Windows 3.x BMP file.\n      // See: https://www.fileformat.info/format/bmp/egff.htm\n      return 12;\n    }\n\n    return 0;\n  }\n\n  get paletteColorCount() {\n    if (this.depth <= 8) {\n      return this.colorsUsed || 1 << this.depth;\n    }\n    return 0;\n  }\n\n  get paletteSize() {\n    const bytesPerColor = this.headerType === HeaderType.Core ? 3 : 4;\n    return this.paletteColorCount * bytesPerColor;\n  }\n\n  get stride() {\n    return ((this.width * this.depth + 31) & ~31) >> 3;\n  }\n\n  get hasBitMasks() {\n    switch (this.headerType) {\n      case HeaderType.Core:\n        return false;\n      case HeaderType.Info:\n        return this.compression === Compression.BitFields;\n      default:\n        return true;\n    }\n  }\n\n  get redMask() {\n    if (!this.hasBitMasks) {\n      return 0;\n    } else {\n      return this.readUint32(40);\n    }\n  }\n\n  get greenMask() {\n    if (!this.hasBitMasks) {\n      return 0;\n    } else {\n      return this.readUint32(44);\n    }\n  }\n\n  get blueMask() {\n    if (!this.hasBitMasks) {\n      return 0;\n    } else {\n      return this.readUint32(48);\n    }\n  }\n\n  get alphaMask() {\n    if (!this.hasBitMasks || this.headerType === HeaderType.V2) {\n      return 0;\n    } else {\n      this.readUint32(52);\n    }\n  }\n\n  colorFromPalette(index) {\n    this.initialize();\n\n    if (index >= this.paletteColors.length) {\n      return this.colorFromPalette(0);\n    }\n\n    return this.paletteColors[index];\n  }\n\n  validateHeader() {\n    if (\n      this.dataView.byteLength < 4 ||\n      this.dataView.byteLength < this.headerSize\n    ) {\n      throw new Error(\"Truncated header\");\n    }\n\n    if (!Object.values(HeaderType).includes(this.headerType)) {\n      throw new Error(`Unknown header type with size ${this.headerSize}.`);\n    }\n\n    if (this.width < 0) {\n      throw new Error(\"Image width less than zero\");\n    }\n\n    if (\n      this.width > 0x40000000 ||\n      this.height < -0x40000000 ||\n      this.height > 0x40000000\n    ) {\n      throw new Error(\"Image dimensions out of bounds\");\n    }\n\n    if (this.planes !== 1) {\n      throw new Error(`Invalid number of color planes (${this.planes})`);\n    }\n\n    switch (this.depth) {\n      case 1:\n      case 2:\n      case 4:\n      case 8:\n      case 16:\n      case 24:\n        break;\n      case 32:\n        if (this.headerType === HeaderType.Core) {\n          throw new Error(`32 is an invalid bit depth for ${this.headerType}`);\n        }\n        break;\n      default:\n        throw new Error(\"Unsupported bit depth\");\n    }\n\n    if (\n      this.compression !== Compression.RGB &&\n      this.compression !== Compression.BitFields\n    ) {\n      throw new Error(\"Unsupported compression\");\n    }\n\n    if (this.colorsUsed > 1 << this.depth) {\n      throw new Error(\n        `Palette size ${this.paletteColorCount} exceeds maximum value for ${this.depth}-bit image`\n      );\n    }\n  }\n\n  validateBitFields() {\n    if (this.bitFields) {\n      let maxmask = (1 << NUM_CONVERT_TABLES) - 1;\n      if (\n        this.bitFields.r.mask > maxmask ||\n        this.bitFields.g.mask > maxmask ||\n        this.bitFields.b.mask > maxmask ||\n        this.bitFields.a.mask > maxmask\n      ) {\n        throw new Error(\"Bit mask too long\");\n      }\n    }\n  }\n\n  determineHeaderType() {\n    if (this.dataView.byteLength < 4) {\n      return;\n    }\n    switch (this.headerSize) {\n      case 12:\n        this.headerType = HeaderType.Core;\n        break;\n      case 40:\n        this.headerType = HeaderType.Info;\n        break;\n      case 52:\n        this.headerType = HeaderType.V2;\n        break;\n      case 56:\n        this.headerType = HeaderType.V3;\n        break;\n      case 108:\n        this.headerType = HeaderType.V4;\n        break;\n      case 124:\n        this.headerType = HeaderType.V5;\n        break;\n    }\n  }\n\n  determineReadLineStrategy() {\n    switch (this.depth) {\n      case 1:\n      case 2:\n      case 4:\n      case 8:\n        this.readLineStrategy = new PalettedReadLineStrategy(this);\n        break;\n      case 16:\n      case 24:\n      case 32:\n        this.readLineStrategy = new DefaultReadLineStrategy(this);\n        break;\n      default:\n        throw Error(`Unhandled bit depth: ${this.depth}`);\n    }\n  }\n\n  decodeBitFields() {\n    if (this.compression === Compression.BitFields) {\n      this.bitFields = new BitFields(\n        this.redMask,\n        this.greenMask,\n        this.blueMask,\n        this.alphaMask\n      );\n    } else {\n      switch (this.depth) {\n        case 16:\n          this.bitFields = new BitFields(\n            0x00007c00,\n            0x000003e0,\n            0x0000001f,\n            0x00000000\n          );\n          break;\n\n        case 24:\n        case 32:\n          this.bitFields = new BitFields(\n            0x00ff0000,\n            0x0000ff00,\n            0x000000ff,\n            0x00000000\n          );\n          break;\n      }\n    }\n  }\n\n  indexPalette() {\n    if (this.compression === Compression.BitFields) {\n      return;\n    }\n\n    this.paletteColors = new Array(this.paletteColorCount);\n    let pos = this.headerSize + this.optionalBitMasksSize;\n\n    for (let i = 0; i < this.paletteColors.length; ++i) {\n      this.paletteColors[i] = new PaletteColor(\n        this.readUint8(pos++),\n        this.readUint8(pos++),\n        this.readUint8(pos++)\n      );\n\n      if (this.headerType !== HeaderType.Core) {\n        // rgbReserved is reserved and must be zero\n        // See: https://learn.microsoft.com/en-us/windows/win32/api/wingdi/ns-wingdi-rgbquad\n        pos++;\n      }\n    }\n  }\n\n  initialize() {\n    if (this.initialized) {\n      return;\n    }\n\n    this.determineHeaderType();\n    this.validateHeader();\n    this.determineReadLineStrategy();\n    this.decodeBitFields();\n    this.validateBitFields();\n    this.indexPalette();\n\n    this.initialized = true;\n  }\n\n  read() {\n    this.initialize();\n\n    const rowCount = Math.abs(this.height);\n    let imageData = new Uint8ClampedArray(this.width * rowCount * 4);\n\n    for (let row = 0; row < rowCount; ++row) {\n      this.readLineStrategy.read(imageData, row);\n    }\n\n    return imageData;\n  }\n}\n\nclass ReadLineStrategy {\n  constructor(reader) {\n    this.reader = reader;\n    this.width = this.reader.width;\n    this.height = this.reader.height;\n  }\n\n  read(outBuffer, row) {\n    const isBottomUp = this.height < 0;\n    const line = isBottomUp ? row : this.height - 1 - row;\n\n    const outPos = this.width * row * 4;\n    const linePos =\n      this.reader.headerSize +\n      this.reader.optionalBitMasksSize +\n      this.reader.paletteSize +\n      this.reader.stride * line;\n\n    this.readLine(outBuffer, outPos, linePos);\n  }\n\n  readLine(_outBuffer, _outPos, _linePos) {\n    throw new Error(\"ReadLineStrategy.readLine() must be implemented\");\n  }\n\n  getAlpha(r, g, b) {\n    if (r !== 0 || g !== 0 || b !== 0) {\n      return 0xff;\n    } else {\n      return 0x00;\n    }\n  }\n}\n\nclass DefaultReadLineStrategy extends ReadLineStrategy {\n  constructor(reader) {\n    super(reader);\n    this.bytesPerPixel = this.reader.depth >> 3;\n  }\n\n  readLine(outBuffer, outPos, linePos) {\n    for (let i = 0; i < this.width; ++i) {\n      let r = 0;\n      let g = 0;\n      let b = 0;\n\n      let p = this.readUint32WithZeroPadding(linePos);\n      r = this.bitFields.r.read(p);\n      g = this.bitFields.g.read(p);\n      b = this.bitFields.b.read(p);\n\n      outBuffer[outPos++] = r;\n      outBuffer[outPos++] = g;\n      outBuffer[outPos++] = b;\n      outBuffer[outPos++] = this.getAlpha(r, g, b);\n\n      linePos += this.bytesPerPixel;\n    }\n  }\n\n  readUint32WithZeroPadding(position) {\n    if (position + 4 <= this.reader.dataView.byteLength) {\n      return this.reader.readUint32(position);\n    }\n\n    let bytes = new Uint8Array([0, 0, 0, 0]);\n\n    for (let i = 0; i < bytes.length; ++i) {\n      if (position >= this.reader.dataView.byteLength) {\n        break;\n      }\n      bytes[i] = this.reader.readUint8(position++);\n    }\n\n    return new DataView(bytes.buffer).getUint32(0, true);\n  }\n\n  get bitFields() {\n    return this.reader.bitFields;\n  }\n}\n\nclass PalettedReadLineStrategy extends ReadLineStrategy {\n  constructor(reader) {\n    super(reader);\n    this.pixelsPerByte = 8 / this.reader.depth;\n    this.bytesPerLine = Math.ceil(this.width / this.pixelsPerByte);\n    this.getPaletteIndices = PalettedReadLineStrategy.createGetPaletteIndices(\n      this.reader.depth\n    );\n  }\n\n  static createGetPaletteIndices(depth) {\n    switch (depth) {\n      case 1:\n        return (byte) => {\n          let indices = new Array(8);\n          for (let i = 0; i < 8; ++i) {\n            indices[7 - i] = (byte & (1 << i)) >> i;\n          }\n          return indices;\n        };\n      case 2:\n        return (byte) => {\n          return [\n            (byte & 0xc0) >> 6,\n            (byte & 0x30) >> 4,\n            (byte & 0x0c) >> 2,\n            byte & 0x03,\n          ];\n        };\n      case 4:\n        return (byte) => {\n          return [(byte & 0xf0) >> 4, byte & 0x0f];\n        };\n      case 8:\n        return (byte) => {\n          return [byte];\n        };\n      default:\n        throw Error(`Unhandled bit depth: ${depth}`);\n    }\n  }\n\n  readLine(outBuffer, outPos, linePos) {\n    let written = 0;\n\n    for (let i = 0; i < this.bytesPerLine; ++i) {\n      const byte = this.readUint8WithZeroPadding(linePos);\n      const paletteIndices = this.getPaletteIndices(byte);\n\n      for (let paletteIndex of paletteIndices) {\n        const color = this.reader.colorFromPalette(paletteIndex);\n        const { b, g, r } = color;\n\n        outBuffer[outPos++] = r;\n        outBuffer[outPos++] = g;\n        outBuffer[outPos++] = b;\n        outBuffer[outPos++] = this.getAlpha(r, g, b);\n\n        if (++written === this.width) {\n          return;\n        }\n      }\n\n      ++linePos;\n    }\n  }\n\n  readUint8WithZeroPadding(position) {\n    if (position < this.reader.dataView.byteLength) {\n      return this.reader.readUint8(position);\n    }\n    return 0;\n  }\n}\n","const ResourceType = {\n  CURSOR: 1,\n  BITMAP: 2,\n  ICON: 3,\n  MENU: 4,\n  DIALOG: 5,\n  STRING_TABLE: 6,\n  FONT_DIRECTORY: 7,\n  FONT: 8,\n  ACCELERATOR: 9,\n  UNFORMATTED: 10,\n  MESSAGE_TABLE: 11,\n  GROUP_CURSOR: 12,\n  GROUP_ICON: 14,\n  VERSION_INFORMATION: 16,\n};\n\nclass ResourceDirectoryEntry {\n  constructor(resourceType, subdirectoryOffset) {\n    this.resourceType = resourceType;\n    this.subdirectoryOffset = subdirectoryOffset;\n  }\n}\n\nclass ResourceDataEntry {\n  constructor(offset, size, codePage, unused) {\n    this.offset = offset;\n    this.size = size;\n    this.codePage = codePage;\n    this.unused = unused;\n  }\n}\n\nclass ResourceInfo {\n  constructor(start, size, width, height) {\n    this.start = start;\n    this.size = size;\n    this.width = width;\n    this.height = height;\n  }\n}\n\nexport class PEReader {\n  constructor(buffer) {\n    this.file = buffer;\n    this.dataView = new DataView(buffer);\n    this.position = 0;\n    this.virtualAddress = 0;\n    this.rootAddress = 0;\n\n    this.bitmapDirectoryEntry = new ResourceDirectoryEntry();\n    this.resourceInfo = new Map();\n\n    this.readHeader();\n    this.readBitmapTable();\n  }\n\n  seek(position) {\n    this.position = position;\n  }\n\n  skip(offset) {\n    this.position += offset;\n  }\n\n  readUint16() {\n    let result = this.dataView.getUint16(this.position, true);\n    this.position += 2;\n    return result;\n  }\n\n  readUint32() {\n    let result = this.dataView.getUint32(this.position, true);\n    this.position += 4;\n    return result;\n  }\n\n  readInt32() {\n    let result = this.dataView.getInt32(this.position, true);\n    this.position += 4;\n    return result;\n  }\n\n  readString(length) {\n    let decoder = new TextDecoder(\"utf-8\");\n    let result = decoder.decode(\n      new Uint8Array(this.file.slice(this.position, this.position + length))\n    );\n    this.position += length;\n    return result;\n  }\n\n  readDirectoryEntryCount() {\n    this.skip(0x0c);\n    let namedEntries = this.readUint16();\n    let idEntries = this.readUint16();\n    return namedEntries + idEntries;\n  }\n\n  readResourceDirectoryEntry() {\n    let resourceType = this.readUint32();\n    let subdirectoryOffset = this.readUint32();\n    return new ResourceDirectoryEntry(resourceType, subdirectoryOffset);\n  }\n\n  readResourceDataEntry() {\n    let offset = this.readUint32();\n    let size = this.readUint32();\n    let codePage = this.readUint32();\n    let unused = this.readUint32();\n    return new ResourceDataEntry(offset, size, codePage, unused);\n  }\n\n  readHeader() {\n    this.seek(0x3c);\n    let peHeaderAddress = this.readUint16();\n\n    this.skip(peHeaderAddress - 0x3c - 0x02);\n    let type = this.readString(4);\n    if (type !== \"PE\\0\\0\") {\n      throw new Error(\"Invalid PE file signature\");\n    }\n\n    this.skip(0x02);\n    let sections = this.readUint16();\n\n    this.skip(0x78 - 0x04 + 0x0c);\n    this.virtualAddress = this.readUint32();\n\n    this.skip(0x6c + 0x08 + 0x04);\n\n    for (let i = 0; i < sections; ++i) {\n      let checkVirtualAddress = this.readUint32();\n      if (checkVirtualAddress == this.virtualAddress) {\n        this.skip(0x04);\n        this.rootAddress = this.readUint32();\n        break;\n      }\n      this.skip(0x24);\n    }\n\n    if (this.rootAddress == 0) {\n      throw new Error(\"Invalid root address\");\n    }\n\n    this.seek(this.rootAddress);\n    let directoryEntryCount = this.readDirectoryEntryCount();\n\n    for (let i = 0; i < directoryEntryCount; ++i) {\n      let directoryEntry = this.readResourceDirectoryEntry();\n      if (directoryEntry.resourceType === ResourceType.BITMAP) {\n        this.bitmapDirectoryEntry = directoryEntry;\n        this.bitmapDirectoryEntry.subdirectoryOffset -= 0x80000000;\n        return;\n      }\n    }\n\n    throw new Error(\"Missing bitmap resource directory\");\n  }\n\n  readBitmapTable() {\n    this.seek(this.rootAddress + this.bitmapDirectoryEntry.subdirectoryOffset);\n\n    let directoryEntryCount = this.readDirectoryEntryCount();\n    let bitmapEntries = new Array();\n    for (let i = 0; i < directoryEntryCount; ++i) {\n      let entry = this.readResourceDirectoryEntry();\n      if (entry.subdirectoryOffset > 0x80000000) {\n        entry.subdirectoryOffset -= 0x80000000;\n        bitmapEntries.push(entry);\n      }\n    }\n\n    for (let entry of bitmapEntries) {\n      this.seek(this.rootAddress + entry.subdirectoryOffset + 20);\n      let entrySubdirectoryOffset = this.readUint32();\n\n      this.seek(this.rootAddress + entrySubdirectoryOffset);\n      let dataEntry = this.readResourceDataEntry();\n      let start = dataEntry.offset - this.virtualAddress + this.rootAddress;\n      let size = dataEntry.size;\n\n      this.seek(start);\n\n      let headerSize = this.readUint32();\n      let width;\n      let height;\n\n      if (headerSize === 12) {\n        // BITMAPCOREHEADER: width and height are unsigned 16-bit values\n        // See: https://learn.microsoft.com/windows/win32/api/wingdi/ns-wingdi-bitmapcoreheader\n        width = this.readUint16();\n        height = this.readUint16();\n      } else {\n        width = Math.abs(this.readInt32());\n        height = Math.abs(this.readInt32());\n      }\n\n      this.resourceInfo.set(\n        entry.resourceType,\n        new ResourceInfo(start, size, width, height)\n      );\n    }\n  }\n\n  getResourceIDs() {\n    return this.resourceInfo.keys();\n  }\n\n  getResourceInfo(resourceID) {\n    let info = this.resourceInfo.get(resourceID);\n    if (!info) {\n      info = null;\n    }\n    return info;\n  }\n\n  readResource(info) {\n    return this.file.slice(info.start, info.start + info.size);\n  }\n}\n","import { LoadType } from \"./load-type\";\nimport { DIBReader } from \"./dib-reader\";\nimport { PEReader } from \"./pe-reader\";\n\nself.egfs = new Map();\n\nself.loadDIB = function (data) {\n  try {\n    let egf = egfs.get(data.fileID);\n    if (egf) {\n      let info = egf.getResourceInfo(data.resourceID);\n      if (info) {\n        let dib = egf.readResource(info);\n        let reader = new DIBReader(dib);\n        let pixels = reader.read();\n        postMessage(\n          {\n            loadType: LoadType.DIB,\n            fileID: data.fileID,\n            resourceID: data.resourceID,\n            pixels: pixels.buffer,\n          },\n          [pixels.buffer]\n        );\n      }\n    }\n  } catch (e) {\n    postMessage({\n      loadType: LoadType.DIB,\n      fileID: data.fileID,\n      resourceID: data.resourceID,\n      error: e,\n    });\n  }\n};\n\nself.loadEGF = function (data) {\n  try {\n    if (egfs.has(data.fileID)) {\n      throw new Error(`EGF ${data.fileID} was already loaded.`);\n    }\n\n    let egf = new PEReader(data.buffer);\n\n    egfs.set(data.fileID, egf);\n\n    postMessage({\n      loadType: LoadType.EGF,\n      fileID: data.fileID,\n      resourceInfo: egf.resourceInfo,\n    });\n  } catch (e) {\n    postMessage({\n      loadType: LoadType.EGF,\n      fileID: data.fileID,\n      error: e,\n    });\n  }\n};\n\nonmessage = function (event) {\n  let data = event.data;\n\n  switch (data.loadType) {\n    case LoadType.DIB:\n      loadDIB(data);\n      break;\n    case LoadType.EGF:\n      loadEGF(data);\n      break;\n    default:\n      throw new Error(`Unhandled LoadType: ${data.loadType}`);\n  }\n};\n"],"names":["LoadType","CONVERT_TABLES","tables","Array","i","entries","table","ii","Math","trunc","HeaderType","Core","Info","V2","V3","V4","V5","Compression","PaletteColor","constructor","b","g","r","this","trailingZeros","n","clz32","BitField","mask","shift","length","read","data","BitFields","redMask","greenMask","blueMask","alphaMask","a","DIBReader","buffer","dataView","DataView","headerType","readLineStrategy","bitFields","paletteColors","initialized","readUint8","position","getUint8","readUint16","getUint16","readUint32","getUint32","readInt32","getInt32","headerSize","width","height","planes","depth","compression","colorsUsed","optionalBitMasksSize","paletteColorCount","paletteSize","bytesPerColor","stride","hasBitMasks","colorFromPalette","index","initialize","validateHeader","byteLength","Error","Object","values","includes","validateBitFields","maxmask","determineHeaderType","determineReadLineStrategy","PalettedReadLineStrategy","DefaultReadLineStrategy","decodeBitFields","indexPalette","pos","rowCount","abs","imageData","Uint8ClampedArray","row","ReadLineStrategy","reader","outBuffer","line","outPos","linePos","readLine","_outBuffer","_outPos","_linePos","getAlpha","super","bytesPerPixel","p","readUint32WithZeroPadding","bytes","Uint8Array","pixelsPerByte","bytesPerLine","ceil","getPaletteIndices","createGetPaletteIndices","byte","indices","written","readUint8WithZeroPadding","paletteIndices","paletteIndex","color","ResourceType","ResourceDirectoryEntry","resourceType","subdirectoryOffset","ResourceDataEntry","offset","size","codePage","unused","ResourceInfo","start","PEReader","file","virtualAddress","rootAddress","bitmapDirectoryEntry","resourceInfo","Map","readHeader","readBitmapTable","seek","skip","result","readString","TextDecoder","decode","slice","readDirectoryEntryCount","readResourceDirectoryEntry","readResourceDataEntry","peHeaderAddress","sections","directoryEntryCount","directoryEntry","bitmapEntries","entry","push","entrySubdirectoryOffset","dataEntry","set","getResourceIDs","keys","getResourceInfo","resourceID","info","get","readResource","self","egfs","loadDIB","egf","fileID","dib","pixels","postMessage","loadType","e","error","loadEGF","has","onmessage","event"],"sourceRoot":""}